<!-- 前端问题 -->

# 防抖和节流？

## 防抖

- 持续触发不执行
- 不触发的一段时间之后再执行一个回调函数

## 节流

- 持续触发并不会执行多次
- 到一定时间再去执行一个回调函数

# 元素垂直水平居中？

```css
/* 1  flex */
.p {
  display: flex;
  justify-content: center; /* 水平 */
  align-items: center; /* 垂直 */
}
/* 2 transform*/
.p {
  position: relative;
}
.c {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
/* 3 通过设置父容器相对定位，子级设置绝对定位，标签通过margin实现自适应居中； */
.p {
  position: relative;
}
.c {
  /* 四个方向设置为0, 然后通过margin为auto自适应居中 减去一半值同理*/
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  margin: auto;
}
```

# 如何自适应各种屏幕适配？

- <meta name="viewport" content="width=device-width,initial-scale=1" />
- 百分比
- rem
- 媒体查询器@media 如果屏幕宽度小于 400 像素(max-device-width: 400px)

# JavaScript 中捕获/阻止捕获、冒泡/阻止冒泡？

冒泡的终点最终可以冒泡到 window 上，即使是有 iframe 的话，也是不影响的

- stopPropagation()方法既可以阻止事件冒泡，也可以阻止事件捕获，也可以阻止处于目标阶段。
- stopImmediatePropagation()方法来阻止事件捕获，另外此方法还可以阻止事件冒泡。
- 那么 stopImmediatePropagation() 和 stopPropagation()的区别在哪儿呢？
  后者只会阻止冒泡或者是捕获。 但是前者除此之外还会阻止该元素的其他事件发生，
  但是后者就不会阻止其他事件的发生。
- DOM2 级事件规定的时间流包括 三个阶段：事件捕获阶段 处于目标阶段 事件冒泡阶段
- 注意：在 DOM 事件流中，实际的目标在捕获阶段不会接收到事件，下一个阶段是处于目标阶段，这时事件被触发，最后进入事件冒泡阶段。我们认为处于目标阶段是事件冒泡阶段的一部分。

# 如何实现一个深拷贝

- 利用 JSON 类 JSON.parse(JSON.stringify(a)); 缺点是不能转化引用对象（转化为引用地址指针）
- 遍历数组的方法从新回调

# keep-alive

- vue 内置组件 实现组件缓存
- 配置在 router.mate meta: {isKeepAlive: true} ,然后在 router-view 进行 if 判断

```html
<!-- router -->
[path: '/createResume', meta: { isKeepAlive: true }]
<keep-alive>
  <router-view v-if="$route.meta.isKeepAlive"></router-view>
</keep-alive>
```

# vue.filter() 过滤器 vue 内置方法

## 绑定

```html
<!-- 在双花括号中 -->
{{ message | capitalize }}

<!-- 在 `v-bind` 中 -->
<div v-bind:id="rawId | formatId"></div>
```

## 局部过滤器

```js
filters: {
  capitalize: function (value) {
    if (!value) return ''
    value = value.toString()
    return value.charAt(0).toUpperCase() + value.slice(1)
  }
}
```

## 全局过滤器

```js
Vue.filter("capitalize", function (value) {
  if (!value) return "";
  value = value.toString();
  return value.charAt(0).toUpperCase() + value.slice(1);
});
```

# js 字符串方法？

```js
// slice方法、substring方法、substr方法
var str = "hello world";
console.log(str.slice(3)); //lo world
console.log(str.substring(3)); //lo world
console.log(str.substr(3)); //lo world
console.log(str.slice(3, 7)); //lo w  7表示子字符串最后一个字符后面的位置  简单理解就是包含头不包含尾
console.log(str.substring(3, 7)); //lo w
console.log(str.substr(3, 7)); //lo worl 7表示返回7个字符
// 阿里面试
var str = "www.taobao.com";
var res = str.split("").reverse().join("").replace("oat", "");
console.log(res); //moc.oab.www
```

# js 数组方法？

- 改变原数组 push unshift pop shift reverse sort splice
- concat join slice toString valueOf indexOf lastIndexOf includes Array.from();
- 遍历 forEach map filter every some reduce reduceRight
- find findIndex fill flat flatMap

every 遍历数组 全都满足返回 true 只要有一个不满足 返回 false => 判断数组中所有的元素是否满足某个条件
some 遍历数组 只要有一个元素满足条件就返回 true,都不满足返回 false => 判断数组中是否存在,满足某个条件的元素
includes 判断一个数组是否包含一个指定的值
fill 填充 fill(value start end (默认为 array.length))
flat(Infinity) 拉平就是扁平化 传入次数，返回新数组
flatMap

# 数组扁平化

let ary = [1, [2, [3, [4, 5]]], 6];
let str = JSON.stringify(ary);

- arr.flat(Infinity) 拉平最大次数
- str.replace(/(\[\]))/g, '').split(',');
- 递归处理
- 扩展运算符

  2.深拷贝与浅拷贝的区别？如何实现一个深拷贝？

```js
// 深层逻辑在于将引用类型转换成为基本数据类型
let result = JSON.parse(JSON.stringify(obj));
// 循环 for in 递归 深层遍历，返回新对象
```

# 普通函数和箭头函数有什么区别？

- 箭头函数是匿名函数，不能作为构造函数，不能使用 new
- 箭头函数不绑定 arguments，取而代之用 rest 参数...解决
- 箭头函数不绑定 this，会捕获其所在的上下文的 this 值，作为自己的 this 值
- 也不会因为 bind,call,apply 改变 this 的指向
- 箭头函数没有原型属性 不能使用 new 构造函数
- 箭头函数不能当做 Generator 函数,不能使用 yield 关键字
- 不能简单返回对象字面量

# 5.typeof 与 instanceof 的区别和相同点？

typeof :的判断类型返回结果有限，只能判断是那个基本类型，引用类型均返回 object null 为 object
instanceof:是用于判断当前类型的 prototype 是不是属于当前的类型 返回 true 或 false
比如 arr instaceof Array //true arr instanceof Object //true 1.返回值为布尔值;

# 6.H5 css3 新特性？

# 7.CSS 的两种盒模型?

https://zhuanlan.zhihu.com/p/110617108
W3C 盒子模型(标准盒模型)
IE 盒子模型(怪异盒模型)

- 如何在 CSS 设置这两个模型
  标准盒模型：box-sizing: content-box
  怪异盒模型：box-sizing: border-box
- 宽度和高度的计算方式不同
  标准盒模型：
  width = content-width
  height = content-height
  怪异盒模型:
  width = content-width + padding-width + border-width
  height = content-height + padding-height + border-height

# 8.常用的布局方法

一、静态布局（static layout）
二、流式布局（Liquid Layout）
三、自适应布局（Adaptive Layout）
四、响应式布局（Responsive Layout）
五、弹性布局（rem/em 布局）
https://www.cnblogs.com/mm152534/p/9429939.html

# 9.浏览器事件

https://blog.csdn.net/weixin_44135121/article/details/90597142

# 10.浏览器事件循环机制（event loop）

- 宏任务：
  浏览器 Node
  I/O ✅ ✅
  setTimeout ✅ ✅
  setInterval ✅ ✅
  setImmediate ❌ ✅
  requestAnimationFrame ✅ ❌
  requestldleCallback ✅ ❌
  script(整体代码)
  UI 交互事件
  postMessage
  MessageChannel

- 微任务：
  浏览器 Node
  process.nextTick ❌ ✅
  MutationObserver ✅ ❌
  Promise.then catch finally ✅ ✅
  Object.observe

# 11.一次完整的浏览器请求流程

域名解析 -->
发起 TCP 的 3 次握手 -->
建立 TCP 连接后发起 http 请求 -->
服务器响应 http 请求，浏览器得到 html 代码 -->
浏览器解析 html 代码，并请求 html 代码中的资源（如 js、css、图片等） -->
浏览器对页面进行渲染呈现给用户

# 什么是 BFC IFC,如何触发？

- 触发 BFC：
  body 根元素
  浮动元素：float 除 none 以外的值
  绝对定位元素：position (absolute、fixed)
  display 为 inline-block、table-cells、flex
  overflow 除了 visible 以外的值 (hidden、auto、scroll)
  注意根元素就创建了个 BFC
- 那么 BFC 又有以下特点：
  内部块级盒子垂直方向排列
  盒子垂直距离由 margin 决定，同一个 BFC 盒子的外边距会重叠
  BFC 就是一个隔离的容器，内部子元素不会影响到外部元素
  BFC 的区域不会与 float box 叠加
  每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。
- BFC 的用途：
  清除浮动
  解决外边距合并
  布局

# vue 中 key 是干嘛的？

实现复用更新代码用的，给 diff 算法提供一个 key 值，如果变化就更新对应

# 如何关闭浏览器返回按钮？

https://www.cnblogs.com/yangjing1314/p/10189241.html

```js
window.addEventListener(
  "popstate",
  function (e) {
    stop;
    alert("我监听到了浏览器的返回按钮事件啦"); //根据自己的需求实现自己的功能
  },
  false
);
function pushHistory() {
  var state = {
    title: "title",
    url: "#",
  };
  window.history.pushState(state, "title", "#");
}
```

# 获取插槽内容

```js
this.$router.solts.default; // 默认插槽
this.$router.solts.xxx; //具名插槽
```

# isNaN()和 Number.isNaN()的用法和区别

- isNaN()es5api 判断是否为 NAN
- Number.isNaN()es6api，判断是否严格等于 NAN，会先判断值是否为数值，不是直接返回 false
<!-- 后端问题 -->

# java 的设计模式？

设计模式分为 3 类 创建型模式 结构型模式 行为型模式

- 简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。
- 工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。
- 抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。
- 原型模式：通过复制现有的实例来创建新的实例。
- 代理模式：为其他对象提供一个代理以便控制这个对象的访问。
- 观察者模式：对象间的一对多的依赖关系。

# 如何遍历二叉树？3种遍历方式
- 前序遍历 首先访问根节点，然后访问根节点的左子树，在访问根节点的右子树。
- 中序遍历 首先访问根节点的左子树，然后访问根节点，再访问根节点右子树
- 后序遍历 首先访问根节点的左子树，然后访问根节点的右子树，最后访问根节点
# 问 HR？

- 有没有试岗期
- 5 险一金
- 请假，作修
- 多长时间给消息

# 问技术部？

- 用什么技术栈 vue
- 招多少人
- 想招一个需要什么技术的
